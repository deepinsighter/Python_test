在本文的第二组图中，可以看到，采用Unicode编码的大写英文字母A，其编码为00 41(之前曾经解释了Windows在处理Unicode字符的时候先处理低八位，
后处理高八位)，因为Unicode存储的任何字符都占用2个字节的空间，所以在解码的时候就两个字节两个字节地取。如果发现高八位不是00，则认为这两个
字节表示一个非ASCII字符，反之如果发现高八位为00，则可知，该字符为ASCII字符，于是取出低八位，再根据ASCII码表查到对应字符，因为取出的低八
位认为表示的是一个ASCII字符，所以字符空间为2的8次方，也就是256个，因此采用Unicode编码表式的ASCII字符属于扩展的ASCII字符集。

?

在第二组图的ANSI编码解释中可以看到，存储一个大写英文字母A仅用了一个字节，内容为41。十六进制的41转换为八位的二进制后应该是?01000001，可以
看到，此二进制数的最高位为0，ANSI编码在存储ASCII字符时采用的是传统的ASCII字符集，其字符数量为128，正好2的7次方就是128，因此最高位一定是0。
汉字“宋”的ANSI编码为CB CE，将这两个字节的十六进制数转换为二进制，结果为[11001011][11001110]?，每个字节的最高位都是1，由此可以推断在解码
的时候，一次读取一个字节的内容，看一下该字节的最高位是否为1，如果为1，暂存该字节，并读取下一个字节，新读取的这个字节的最高位应该也为1，这样
将两个字节合并然后去查询对应的字符；如果第一次读到的一个字节最高位为0，那么就按此字节的内容直接查询传统的ASCII码表，找到对应的字符。

?

最后再分析Windows中的回车换行特点。在开始的时候为了准备这个实验用的文本文档，在输入完ABC后又输入了一个回车。但是通过分析得知，在文本存储的
时候并不是仅存了一个“回车”，还存了一个“换行”，而且是先存储的“回车”后存储的“换行”(见ASCII码表：0D->回车；0A->换行)，这与Linux/Unix中
的换行方式不同，在Linux/Unix中仅用一个0D(回车)就可以令文本换行。如果将一个在Linux/Unix中编写的文本文档直接拷贝到Windows中打开(最简单的可以在
Windows下查看百度首页的源代码)，就会看到这些文字几乎都是连着的，没有换行，那是因为在该文档中并没有显式地存储0A(换行符)，虽然这篇文章在Linux/
Unix中看起来很正常。
